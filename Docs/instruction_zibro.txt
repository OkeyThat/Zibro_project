'집으로' 라는 서비스는 '이용자가 요청한 물건은 집까지(목적지까지) 배송해주는 물류 서비스'입니다. 

초기 아이디어 컨셉
    : 오프라인 마트에서 장을 보고 무거운 짐을 '자차'에 실어 집으로 옮기는 일이 힘들어 기획한 서비스이다. 
    (기획 해보니 노약자/장애인 등 거동이 불편한 사람도 이용하기 좋은 서비스로 생각되었다.)

현재 아이디어
    : 배송 요청자(마트 점주, 무거운 짐을 든 사람 등)가 서비스에 '배송 요청'으로 등록하면 배송 담당자(배송기사, 일반 배송담당 등록자 등)가 
    배송지, 배송물건 등을 확인하여 배송하고 배송수수료를 받는 시스템(서비스)로 기획하였다.

    : 마트 점주를 생각한 이유는 '장보고 무료배송'서비스를 하고 있는 마트 점주를 대상으로도 서비스 도입이 가능하다고 판단하였다.
    (점주의 유지비용을 줄이면 '무료배송'서비스하는 마트가 많아지니 '집으로'초기 목표에 부합한다고 생각함)

아이디어에 대한 기능 명세 리스트 
    :
## 배송 요청자 (Delivery Requester)

- 회원가입/로그인 (Sign-up/Login)
    - 소셜 로그인 (카카오, 네이버 등)
    - 이메일/비밀번호 기반 회원가입
    - 아이디/비밀번호 찾기
- 배송 요청 (Request Delivery)
    - 물품 정보 입력 (사진, 카테고리, 수량)
    - 출발지/도착지 설정 (지도 기반)
    - 배송 시간 선택 (실시간, 예약)
    - 결제 (카드 등록, 간편 결제)
    - 쿠폰/포인트 사용
- 실시간 배송 추적 (Real-time Delivery Tracking)
    - 배송 담당자 위치 실시간 확인
    - 예상 도착 시간 확인
    - 배송 담당자와의 채팅/전화
- 이용 내역 (Usage History)
    - 과거 배송 내역 목록
    - 상세 내역 확인
    - 리뷰 작성/확인
- 고객 지원 (Customer Support)
    - 1:1 문의
    - FAQ
    - 공지사항

## 배송 담당자 (Delivery Person)

- 회원가입/로그인 (Sign-up/Login)
    - 운전면허증 등 자격증 인증
    - 계좌 등록
- 배송 목록 확인 (View Delivery List)
    - 주변 배송 요청 실시간 목록
    - 배송 요청 필터링 (거리, 수수료 등)
    - 배송 수락/거절
- 배송 진행 (Delivery in Progress)
    - 요청자 정보 및 물품 정보 확인
    - 내비게이션 앱 연동
    - 배송 완료 사진 전송
- 수익 관리 (Earnings Management)
    - 일/주/월별 수익 내역 확인
    - 정산 계좌 관리

## 관리자 (Administrator)

- 사용자 관리 (User Management)
    - 회원 정보 조회 및 수정
    - 블랙리스트 관리
- 배송 관리 (Delivery Management)
    - 실시간 배송 현황 대시보드
    - 배송 데이터 통계 및 분석
- 정산 관리 (Settlement Management)
    - 배송 수수료 정산 주기 설정
    - 정산 내역 엑셀 다운로드
- 고객 지원 관리 (Customer Support Management)
    - 1:1 문의 답변 및 처리
    - FAQ 및 공지사항 등록/수정


# 화면 구성 기획

## 1. 배송 요청자 (Delivery Requester)

### 메인 화면 (Main Screen)

- 배송 요청 시작 버튼
- 진행 중인 배송 현황 요약
- 과거 이용 내역 바로가기
- 고객 지원/마이페이지 접근

### 배송 요청 화면 (Delivery Request Screen)

- 물품 정보 입력 (사진 첨부, 카테고리 선택, 수량 입력)
- 출발지/도착지 설정 (지도 기반 주소 검색, 현재 위치 자동 설정)
- 배송 시간 선택 (즉시 배송, 예약 배송)
- 결제 정보 입력 (카드 선택/등록, 간편 결제 선택)
- 쿠폰/포인트 적용
- 최종 결제 금액 확인 및 요청 버튼

### 배송 현황 화면 (Delivery Status Screen)

- 실시간 배송 담당자 위치 지도 표시
- 예상 도착 시간
- 배송 담당자 정보 (사진, 이름, 평점)
- 배송 담당자와 채팅/전화 버튼
- 배송 진행 단계 표시 (접수, 픽업 중, 배송 중, 완료)

### 이용 내역 상세 화면 (Usage History Detail Screen)

- 과거 배송 정보 요약
- 결제 내역
- 배송 담당자 평점 및 리뷰 작성/확인

### 마이페이지 (My Page)

- 개인 정보 수정
- 결제 수단 관리
- 쿠폰/포인트 확인
- 알림 설정
- 고객 지원 (FAQ, 1:1 문의)

## 2. 배송 담당자 (Delivery Person)

### 메인 화면 (Main Screen)

- 주변 배송 요청 목록 (지도 기반)
- 수락한 배송 목록
- 수익 현황 요약
- 마이페이지/설정 접근

### 배송 요청 상세 화면 (Delivery Request Detail Screen)

- 요청 물품 정보, 출발지/도착지, 배송 시간, 예상 수수료
- 수락/거절 버튼

### 배송 진행 화면 (Delivery in Progress Screen)

- 요청자 정보 및 물품 정보 재확인
- 내비게이션 앱 연동 버튼
- 배송 완료 시 사진 첨부 및 완료 버튼

### 수익 관리 화면 (Earnings Management Screen)

- 일/주/월별 수익 그래프 및 상세 내역
- 정산 계좌 정보 확인 및 수정

## 3. 관리자 (Administrator)

### 대시보드 (Dashboard)

- 전체 배송 현황 요약 (진행 중, 완료, 취소 건수)
- 사용자/배송 담당자 통계
- 수익 통계

### 사용자 관리 (User Management)

- 회원 목록 조회, 상세 정보 확인, 수정, 블랙리스트 등록/해제

### 배송 관리 (Delivery Management)

- 전체 배송 목록 조회, 상세 현황 확인, 강제 완료/취소 처리

### 정산 관리 (Settlement Management)

- 정산 내역 조회, 정산 주기 설정, 엑셀 다운로드

### 고객 지원 관리 (Customer Support Management)

- 1:1 문의 목록 조회, 답변 작성, FAQ/공지사항 등록/수정

# 기능 Flow 차트

## A. 배송 요청자 Flow

1. 서비스 시작: 앱 실행 -> 메인 화면
2. 배송 요청: 메인 화면 -> 배송 요청 시작 -> 물품/위치/시간/결제 정보 입력 -> 배송 요청
3. 배송 추적: 메인 화면/배송 요청 후 -> 배송 현황 화면 (실시간 위치, ETA, 담당자 정보)
4. 배송 완료: 배송 현황 화면 -> 배송 완료 알림 -> 이용 내역 상세 화면 (리뷰 작성)
5. 이용 내역 확인: 메인 화면 -> 이용 내역 -> 이용 내역 상세 화면
6. 고객 지원: 메인 화면/마이페이지 -> 고객 지원 (1:1 문의, FAQ, 공지사항)

## B. 배송 담당자 Flow

1. 서비스 시작: 앱 실행 -> 메인 화면
2. 배송 요청 확인/수락: 메인 화면 (주변 요청 목록) -> 요청 상세 확인 -> 수락/거절
3. 배송 진행: 수락 후 -> 배송 진행 화면 (내비게이션 연동, 물품 픽업, 배송)
4. 배송 완료: 배송 진행 화면 -> 배송 완료 사진 첨부 -> 완료 처리
5. 수익 확인: 메인 화면 -> 수익 관리 화면

## C. 관리자 Flow

1. 로그인: 관리자 페이지 로그인
2. 대시보드: 로그인 후 -> 대시보드 (전체 현황 모니터링)
3. 각 관리 기능: 대시보드/메뉴 -> 사용자/배송/정산/고객 지원 관리 화면 (조회, 수정, 통계 등)

개발에 필요한 설계 초안 기획

# 개발 설계 초안

## 1. 기술 스택 (Technology Stack)

- 클라이언트 (Client): Flutter (Dart)
- 서버 (Server): Python with FastAPI
- 데이터베이스 (Database): PostgreSQL / mongoDB

## 2. 클라이언트 개발 설계 (Flutter)

### 2.1. 아키텍처 (Architecture)

- Riverpod
    
    개념: Flutter에서 상태 관리를 위한 Provider 패밀리 중 하나로, 컴파일 타임 안전성, 테스트 용이성, 유연성을 강조합니다. 의존성 주입을 통해 위젯 트리 외부에서 상태를 관리하고, 필요한 위젯에만 효율적으로 상태를 전달합니다.
    
    ```dart
    // counter_provider.dart
    final counterProvider = StateProvider<int>((ref) => 0);
    
    // main.dart
    class MyHomePage extends ConsumerWidget {
      @override
      Widget build(BuildContext context, WidgetRef ref) {
        final count = ref.watch(counterProvider);
        return Text('$count');
      }
    }
    ```
    
- BLoC Pattern
    
    개념: Business Logic Component의 약자로, UI와 비즈니스 로직을 분리하여 애플리케이션의 상태 변화를 예측 가능하고 테스트하기 쉽게 만듭니다. 이벤트(Event)를 받아 상태(State)를 출력하는 스트림 기반의 패턴입니다.
    
    ```dart
    // counter_bloc.dart
    enum CounterEvent { increment }
    
    class CounterBloc extends Bloc<CounterEvent, int> {
      CounterBloc() : super(0) {
        on<CounterEvent>((event, emit) {
          if (event == CounterEvent.increment) {
            emit(state + 1);
          }
        });
      }
    }
    
    // main.dart
    BlocProvider(
      create: (_) => CounterBloc(),
      child: BlocBuilder<CounterBloc, int>(
        builder: (context, count) {
          return Text('$count');
        },
      ),
    )
    ```
    
- 클린 아키텍처 (Clean Architecture)
    
    개념: 소프트웨어의 계층을 명확히 분리하여 의존성을 외부(프레임워크, 데이터베이스 등)에서 내부(비즈니스 로직)로 향하게 하는 아키텍처 패턴입니다. 이를 통해 비즈니스 로직이 외부 기술에 종속되지 않아 유연하고 테스트하기 쉬운 코드를 만듭니다.
    
    계층 분리:
    
    - Presentation Layer (표현 계층): UI와 사용자 상호작용을 담당합니다. (Flutter 위젯, 페이지)
    - Domain Layer (도메인 계층): 핵심 비즈니스 로직과 엔티티를 포함합니다. (순수 Dart 코드)
    - Data Layer (데이터 계층): 데이터 소스(API, DB)와의 통신을 담당합니다. (Repository 구현, Data Source)
    
    ```
    lib/
    ├── main.dart
    ├── presentation/  (UI, Widgets, Pages, State Management)
    │   ├── pages/
    │   ├── widgets/
    │   └── providers/ (or blocs)
    ├── domain/        (Core Business Logic, Entities, Use Cases, Repositories Interfaces)
    │   ├── entities/
    │   ├── repositories/
    │   └── usecases/
    └── data/          (Data Sources, Repository Implementations, Models)
        ├── datasources/
        ├── models/
        └── repositories/
    ```
    
- 상태 관리: Riverpod 또는 BLoC 패턴 고려 (확장성 및 테스트 용이성)
- 클린 아키텍처 기반의 계층 분리 (Presentation, Domain, Data Layer)

### 2.2. 주요 컴포넌트 (Key Components)

- Dio 라이브러리 활용 (HTTP 통신)
    
    개념: Dio는 Flutter에서 강력한 HTTP 클라이언트 라이브러리입니다. 인터셉터, FormData, 요청 취소, 파일 업로드/다운로드 등 다양한 기능을 제공하여 편리하고 효율적인 네트워크 통신을 가능하게 합니다.
    
    ```dart
    // main.dart
    import 'package:dio/dio.dart';
    
    void getHttp() async {
      try {
        var response = await Dio().get('https://jsonplaceholder.typicode.com/posts/1');
        print(response.data);
      } catch (e) {
        print(e);
      }
    }
    
    // 인터셉터 예시
    Dio dio = Dio();
    dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) {
        // 요청 전에 토큰 추가 등
        options.headers['Authorization'] = 'Bearer your_token';
        return handler.next(options);
      },
      onResponse: (response, handler) {
        // 응답 데이터 처리
        return handler.next(response);
      },
      onError: (DioError e, handler) {
        // 오류 처리
        return handler.next(e);
      },
    ));
    ```
    
- JWT (JSON Web Token) 기반 인증
    
    개념: JWT는 클라이언트와 서버 간에 정보를 안전하게 전송하기 위한 간결하고 자체 포함적인(self-contained) 방법입니다. 주로 사용자 인증 및 정보 교환에 사용됩니다. Header, Payload, Signature 세 부분으로 구성됩니다.
    
    - Header: 토큰 타입 (JWT)과 해싱 알고리즘 (HMAC SHA256 또는 RSA) 정보
    - Payload: 클레임(Claim)이라 불리는 실제 정보 (사용자 ID, 만료 시간 등)
    - Signature: Header와 Payload를 인코딩한 값을 비밀 키로 서명한 값. 토큰의 무결성을 검증하는 데 사용됩니다.
    
    동작 방식:
    
    1. 사용자가 로그인 정보를 서버에 전송합니다.
    2. 서버는 사용자 인증 후, JWT를 생성하여 클라이언트에 응답합니다.
    3. 클라이언트는 JWT를 저장하고, 이후 서버에 요청 시 HTTP 헤더(Authorization: Bearer <token>)에 JWT를 포함하여 전송합니다.
    4. 서버는 요청을 받을 때마다 JWT의 유효성을 검증하고, Payload의 정보를 사용하여 사용자 권한을 확인합니다.
    
    ```
    // JWT 구조 예시
    // Header.Payload.Signature
    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
    eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
    SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
    ```
    
- UI: Material Design 가이드라인 준수, 재사용 가능한 위젯 개발
- API 연동: Dio 라이브러리 활용 (HTTP 통신)
- 로컬 저장소: Shared Preferences 또는 Hive (간단한 데이터 저장)
- 인증/인가: JWT 토큰 기반 인증 구현

### 2.3. UI/UX 원칙 (UI/UX Principles)

- 직관적이고 사용자 친화적인 인터페이스 설계
- 일관된 디자인 시스템 적용

## 3. 서버 개발 설계 (FastAPI)

### 3.1. 아키텍처 (Architecture)

- RESTful API 설계 원칙 준수
    
    개념: 웹 서비스를 설계하는 데 사용되는 아키텍처 스타일로, 자원(Resource)을 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE)를 통해 자원에 대한 CRUD(Create, Read, Update, Delete) 작업을 수행합니다. Stateless(무상태성) 특징을 가지며, 확장성과 유연성이 뛰어납니다.
    
    ```
    GET /users          (모든 사용자 조회)
    POST /users         (새로운 사용자 생성)
    GET /users/{id}     (특정 사용자 조회)
    PUT /users/{id}     (특정 사용자 업데이트)
    DELETE /users/{id}  (특정 사용자 삭제)
    ```
    
- 비동기 처리 (async/await)를 통한 고성능 API 구현
    
    개념: FastAPI는 Python의 비동기 기능을 활용하여 I/O 바운드 작업(데이터베이스 접근, 외부 API 호출 등)을 효율적으로 처리합니다. async와 await 키워드를 사용하여 논블로킹(Non-blocking) 방식으로 작업을 수행함으로써, 단일 스레드에서도 여러 요청을 동시에 처리하는 것처럼 보이게 하여 API의 응답성을 높입니다.
    
    ```python
    from fastapi import FastAPI
    import asyncio
    
    app = FastAPI()
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: int):
        # 비동기적으로 오래 걸리는 작업 시뮬레이션
        await asyncio.sleep(2)
        return {"item_id": item_id, "message": "Item processed asynchronously"}
    ```
    
- 의존성 주입 (Dependency Injection) 활용
    
    개념: FastAPI의 강력한 기능 중 하나로, 함수나 클래스가 필요로 하는 의존성(데이터베이스 세션, 인증된 사용자 등)을 직접 생성하는 대신, 프레임워크가 자동으로 주입해주는 방식입니다. 코드의 재사용성, 테스트 용이성, 유지보수성을 크게 향상시킵니다.
    
    ```python
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    async def get_db():
        db = "database_connection" # 실제 DB 연결 로직
        try:
            yield db
        finally:
            pass # DB 연결 종료 로직
    
    @app.get("/users/")
    async def read_users(db: str = Depends(get_db)):
        return {"message": f"Users from {db}"}
    ```
    
- RESTful API 설계 원칙 준수
- 비동기 처리 (async/await)를 통한 고성능 API 구현
- 의존성 주입 (Dependency Injection) 활용

### 3.2. 데이터베이스 (Database)

- PostgreSQL 사용 (관계형 데이터 모델에 적합)
    
    개념: 강력하고 안정적인 오픈소스 관계형 데이터베이스 관리 시스템(RDBMS)입니다. 복잡한 쿼리, 대용량 데이터 처리, 데이터 무결성 보장에 강점을 가지며, 다양한 데이터 타입과 고급 기능을 지원합니다.
    
- ORM: SQLAlchemy 또는 Tortoise ORM 활용
    
    개념: ORM(Object-Relational Mapping)은 객체 지향 프로그래밍 언어를 사용하여 데이터베이스를 조작할 수 있도록 돕는 기술입니다. SQL 쿼리를 직접 작성하는 대신, 파이썬 객체를 통해 데이터베이스 테이블과 상호작용할 수 있게 하여 개발 생산성을 높입니다.
    
    - SQLAlchemy: Python의 대표적인 ORM으로, 강력하고 유연하며 다양한 데이터베이스를 지원합니다.
    - Tortoise ORM: FastAPI와 잘 어울리는 비동기 ORM으로, 사용하기 쉽고 빠른 개발을 지원합니다.
    
    ```python
    from tortoise import fields, models
    
    class User(models.Model):
        id = fields.IntField(pk=True)
        username = fields.CharField(max_length=255, unique=True)
        email = fields.CharField(max_length=255, unique=True)
        created_at = fields.DatetimeField(auto_now_add=True)
    ```
    
- PostgreSQL 사용 (관계형 데이터 모델에 적합)
- ORM: SQLAlchemy 또는 Tortoise ORM 활용

### 3.3. 주요 API 엔드포인트 (Key API Endpoints)

- 주요 API 엔드포인트 (Key API Endpoints)
    
    개념: 클라이언트가 서버의 특정 기능에 접근하기 위한 고유한 URL입니다. 각 엔드포인트는 특정 자원에 대한 작업을 수행하며, HTTP 메서드(GET, POST, PUT, DELETE)와 함께 사용됩니다.
    
    - 사용자 관리:
    - POST /users/register: 사용자 회원가입
    - POST /users/login: 사용자 로그인
    - GET /users/me: 현재 사용자 정보 조회
    - PUT /users/me: 현재 사용자 정보 수정
    - 배송 요청/관리:
    - POST /deliveries: 배송 요청 생성
    - GET /deliveries/{id}: 특정 배송 요청 조회
    - PUT /deliveries/{id}/status: 배송 상태 업데이트
    - GET /deliveries?status=pending: 특정 상태의 배송 요청 목록 조회
    - 결제/정산:
    - POST /payments: 결제 처리
    - GET /settlements/me: 내 정산 내역 조회
    - 위치/추적:
    - PUT /deliveries/{id}/location: 배송 담당자 위치 업데이트
    - GET /deliveries/{id}/track: 배송 현황 추적
- 사용자 관리: 회원가입, 로그인, 프로필 조회/수정 등
- 배송 요청/관리: 배송 요청 생성, 조회, 상태 업데이트 등
- 결제/정산: 결제 처리, 수익 정산 내역 조회 등
- 위치/추적: 실시간 위치 업데이트, 배송 현황 조회 등

### 3.4. 인증/인가 (Authentication/Authorization)

- OAuth2.0 표준 준수
    
    개념: 서드파티 애플리케이션이 사용자 계정에 직접 접근하지 않고도, 제한된 범위 내에서 사용자 리소스에 접근할 수 있도록 권한을 부여하는 프레임워크입니다. 주로 소셜 로그인(Google, Kakao 등)과 같은 외부 서비스 연동에 사용됩니다.
    
    1. 사용자가 소셜 로그인 버튼 클릭
    2. 클라이언트가 OAuth 제공자(Google 등)에게 인증 요청
    3. OAuth 제공자가 사용자 인증 후, 클라이언트에게 Access Token 발급
    4. 클라이언트가 Access Token을 사용하여 서버에 사용자 정보 요청
    5. 서버가 Access Token을 검증하고 사용자 정보 제공
- JWT (JSON Web Token) 기반 인증
- OAuth2.0 표준 준수

## 4. 배포 전략 (Deployment Strategy)

- 컨테이너화: Docker를 이용한 애플리케이션 컨테이너화
- 클라우드 플랫폼: AWS, Google Cloud Platform (GCP) 또는 Azure 고려
- CI/CD: GitHub Actions 또는 GitLab CI/CD를 통한 자동화된 배포 파이프라인 구축